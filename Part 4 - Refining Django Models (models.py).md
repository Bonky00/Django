# Part 4: Refining Django Models (`myapp/models.py`)

The models generated by `inspectdb` are a fantastic starting point, but they are raw interpretations of your database schema. They often require manual refinement to behave correctly within Django, especially when it comes to relationships and how objects are displayed.

-----

### 4.1 Review the Generated `models.py` File

Open `myproject/myapp/models.py` in your code editor. You'll see several Python classes, each representing one of your database tables.

#### Key Areas to Review and Adjust:

1.  **`managed = False` (Crucial Understanding\!)**

      * For each generated model, you'll see a `Meta` class with `managed = False`:
        ```python
        class YourModelName(models.Model):
            # ... fields ...
            class Meta:
                managed = False
                db_table = 'your_table_name'
        ```
      * **Meaning:** `managed = False` tells Django that it **should NOT** create, modify, or delete this table in the database. Django will simply use the existing table as is.
      * **Why it's important:** Because you're working with an *existing* database, you want Django to *read* from it, not try to manage its schema. **Keep `managed = False` for all models generated from your existing database.** If you remove it, Django will try to create/alter these tables, which will cause errors since they already exist.

2.  **Primary Keys (`primary_key=True`)**

      * `inspectdb` usually does a good job of identifying primary keys. Verify that each model has one field marked with `primary_key=True`.
      * Django models generally assume an `id` field as the primary key if you don't specify one. However, `inspectdb` will use your actual column names (e.g., `program_id`, `outcome_id`). Ensure these match your database.
      * If `inspectdb` defines an `AutoField` for your primary key, it implies the database column is an auto-incrementing integer (like `SERIAL` in PostgreSQL). If your primary key is a regular `INTEGER` and managed by the database, `inspectdb` might use `models.IntegerField(primary_key=True)`.

3.  **Field Types (`models.CharField`, `models.TextField`, etc.)**

      * `inspectdb` makes educated guesses about field types. Review these and adjust if necessary.
          * `VARCHAR(X)` in PostgreSQL often becomes `models.CharField(max_length=X)`.
          * `TEXT` often becomes `models.TextField()`.
          * `INTEGER` becomes `models.IntegerField()`.
          * `BOOLEAN` becomes `models.BooleanField()`.
          * `DATE` or `TIMESTAMP` becomes `models.DateField()` or `models.DateTimeField()`.
      * Ensure `null=True` and `blank=True` are correctly set if the field can be empty in your database.

4.  **Relationships (`models.ForeignKey`, `models.OneToOneField`)**

      * `inspectdb` will identify foreign key relationships. However, it often provides a default `on_delete` action that needs your review.

      * **CRITICAL: Add `on_delete` for Every `ForeignKey` Field**
        Django requires an `on_delete` argument for every `ForeignKey` and `OneToOneField`. This tells Django what to do when the referenced object (the "parent" object) is deleted. `inspectdb` often generates `models.DO_NOTHING` because it can't always infer your desired behavior from the database schema alone.

          * **Example of a Generated `ForeignKey`:**

            ```python
            # Original (from inspectdb, potentially problematic)
            course = models.ForeignKey('Courses', models.DO_NOTHING, db_column='course_id')
            ```

            *(Note: `models.DO_NOTHING` is the positional argument for `on_delete` here.)*

          * **Choosing Your `on_delete` Action:**

              * `models.CASCADE`: When the referenced object is deleted, also delete the objects that have this foreign key. (E.g., delete all `CourseOutcomes` if their associated `Course` is deleted). **Use with caution\!**
              * `models.PROTECT`: Prevent deletion of the referenced object if it still has active references. (E.g., don't delete a `Course` if there are still `CourseOutcomes` linked to it).
              * `models.SET_NULL`: Set the foreign key field to `NULL` when the referenced object is deleted. **Requires `null=True` on the field.** (E.g., if a `CourseOutcome` can exist without a `Course`, set `course_id` to `NULL`).
              * `models.SET_DEFAULT`: Set the foreign key field to its default value when the referenced object is deleted. **Requires `default=...` to be set.**
              * `models.DO_NOTHING`: Do nothing. This means your database's foreign key constraints (if any) will handle the deletion, or you're responsible for manual handling. This is often the safest choice when working with `managed=False` models if you're unsure of the database's `ON DELETE` behavior.

          * **Adjusting the `ForeignKey` (Fixing `TypeError: ForeignKey.__init__() got multiple values`):**
            If you encounter the `TypeError` about multiple `on_delete` values, it means you've accidentally provided `models.DO_NOTHING` as the second positional argument AND a keyword argument `on_delete=...`. **You must choose one.** The safest is to use the `models.DO_NOTHING` that `inspectdb` already put there unless you explicitly want to change the behavior *and* ensure it aligns with your database's constraints.

            ```python
            # Corrected Example (Keeping DO_NOTHING from inspectdb)
            course = models.ForeignKey(
                "Courses",
                models.DO_NOTHING, # Keep this (it's the on_delete action)
                db_column="course_id",
                blank=True,  # Add if the field can be blank in forms
                null=True,   # Add if the field can be NULL in the database
                # REMOVE: on_delete=models.CASCADE, # Do NOT duplicate on_delete!
            )
            ```

5.  **Add `__str__` Methods to Each Model (Highly Recommended\!)**
    The `__str__` method defines the string representation of an object. This is incredibly useful for the Django Admin interface, making records readable instead of just showing "Object (1)".

      * **Add this method inside each `models.Model` class:**

        ```python
        class YourModelName(models.Model):
            # ... existing fields ...

            class Meta:
                managed = False
                db_table = 'your_table_name'

            def __str__(self):
                # Return a meaningful string using fields from THIS model.
                # Example for a Programs model:
                # return self.program_name if hasattr(self, 'program_name') else f"Program ID: {self.program_id}"
                # Example for a Courseoutcomes model (using your actual fields):
                return self.outcome_name or f"Outcome ID: {self.outcome_id}"
                # Ensure the fields (e.g., 'outcome_name', 'outcome_id') actually exist in this model.
        ```

      * **Troubleshooting: `AttributeError: 'ModelName' object has no attribute 'some_field'` in `__str__`**

          * **Reason:** You've tried to access a field (e.g., `self.id`, `self.program_name`) within the `__str__` method that does not actually exist on *that specific model* (or it has a different name).
          * **Solution:** Update the `__str__` method to refer only to fields that are defined within that model's class, using their correct names (e.g., `self.course_id` if your PK is `course_id`, `self.course_title` if that's a descriptive field).

### 4.2 Save `myapp/models.py`

  * **CRITICAL:** After making *any* changes to `myapp/models.py`, you **must save the file**. Many `makemigrations` "no changes detected" errors stem from forgetting this step.
  * **Verification:** Confirm your code editor no longer shows an "unsaved changes" indicator for the file.

-----

**Next up:** We'll finalize the database setup by performing **Part 5: Django Migrations for Existing Database**.

-----
